# Node Architecture

V8 and libuv are fundamental to the Node architecture. The V8 engine converts JavaScript code into machine code. However, that alone is not enough to create a whole server side framework like Node and we need Libuv. Libuv is an open source library with a strong focus on asynchronous IO.
<br /><br />
Libuv gives node access to the underlying computer operating system, file system, networking, and more. Besides that, libuv also implements two extremely important features of NodeJS which are the event loop and the thread pool. The event loop is responsible for handling easy tasks such as executing callbacks and network IO while the thread pool is for more heavy work such as file access and compression. 
<br /><br />
Libuv (written entirely in C++) <br />
V8 engine (written with C++ and JavaScript) <br /><br />
Therefore, NodeJS is written in both C++ and Javascript. The NodeJS architecture allows us to write 100% JavaScript code and still be able to do things such as reading from files which are actually implemented in libuv or other libraries in C++. Other libraries that NodeJS depend on include... http-parser (parsing http), c-ares(DNS Request), OpenSSL(cryptography), and zlib(compression). <br /><br />
<br />
With all this, we end up with NodeJS ready to be used in the server side. <br />

# Node Process and Threads

When we use node on a computer, it means there is a node process running. A process is just a program in execution. In that process, nodeJS basically runs in a single thread. A thread is just a sequence of instructions. Since Node runs in a single thread, it may be easy to block node applications. You need to be very careful of not blocking that thread. <br /><br />

When your program is initialized, all the top level code is executed, which is all the code not inside a callback function. Also, all the modules that your app needs are required and all the callbacks are registered. Then after all that, the event loop fires. The event loop is where most of the work is done in your app, so it's really the heart of the entire node architecture. However, some tasks are too expensive to be executed in the event loop because they would then block the single thread. That's where the thread pool comes in which, just like the event loop, is provided to nodeJS by the libuv library. The thread pool gives us 4 additional threads which are completely separate from the main single thread. These threads together form the thread pool and the event loop can automatically offload the heavy tasks to the thread pool. This all happens behind the scenes. The expensive tasks that do get offloaded are expensive tasks that deal with files, everything related to cryptography like hashing passwords, then all the compression stuff and also DNS lookups (matches web domains to IP addresses) <br /><br />

We are happy because event loop is no longer blocked =) <br /><br />

# Node Event Loop

The event loop is all the application code that is inside callback functions. All code that is not top-level code will run in the event loop. As mentioned above, this is really the heart of the node architecture. NodeJS is all built around callback functions: functions that are called as soon as some function is finished. It works that way because node uses an event triggered architecture. <br /><br />

To clarify, our application receiving an HTTP request on our server, our timer expiring, or a file finishing to read... all these will emit events as soon as they are done with their work and our event loop will then pick up these events and call the callback functions that are associated with each event. <br /><br />

TLDR; the event loop receives events each time something important happens and will then call the necessary callbacks. The event loop receives events, calls the callback functions and offloads the more expensive tasks to the thread pool. Sort of like the orchestrator? =)<br />< br />

When we start our node application, the event loop starts running right away. The event loop has multiple phases and each phase has a callback queue which are the callbacks coming from the events that the event loop receives. The first phase takes care of callbacks of expired timers (ex. setTimeout function) So if there are callback functions from timers, these are the first ones to be processed by the event loop. If a timer expires later during the time when one of the other phases are being processed the callback of that timer will only be called as soon as the event loop comes back to the first phase. <br />< br />

Callbacks in each queue are processed one by one until there are no ones left in the queue and only then will the event loop enter the next phase. The next phase is I/O polling and the execution of I/O callbacks. I/O Polling means looking for I/O events that are ready to be processed and putting them into the callback queue. In the context of NodeJS, I/O means mainly stuff like networking and file access. It's in this phase where probably 99 percent of our code is executed because in a typical node app, the bulk of what we do is related to networking and file accessing. The next phase is for setImmediate callbacks. setImmediate is a special kind of timer that we can use if we want to process callbacks immediately after the I/O polling and execution phase. (For more advanced use cases) <br /><br />

Finally, the 4th phase is for close callbacks. In this event, all close events are processed such as when a webserver or a web socket shuts down. So these are the 4 phases in the event loop but besides these 4 callback queues, there are actually also 2 other queues the nextTick() queue and the other microtasks queue, which is mainly for resolved promises. If there are any callbacks in one of these queues to be processed, they will be executed right after the current phase of the event loop instead of waiting for the entire loop to finish. For example, imagine that a promise resolves and returns some data from an API call while the callback of an expired timer is running. In this case, the promise callback will be executed right after the one from the timer finishes. The same logic also applies to the nextTick() queue. Process.nextTick() is a function that we can use when we really need to execute a certain callback right after the current event loop phase. It's a bit similar to setImmediate() with the difference that setImmediate only runs after the I/O callback phase. But both are for really advanced used cases and I'm still a noob. XD <br /><br />

With that we basically finished one cycle(tick) of the event loop. Now it's time to decide whether the loop should continue with the next tick or if the program should exit. Node simply checks whether there are any timers or I/O tasks that are still running in the background. And if there aren't any then Node will exit the application, but if there are any pending timers or I/O tasks then it will continue running the event loop and go straight to the next tick. So for example when we are listening for incoming HTTP requests, we are basically running an I/O task and that is why the event loop and therefore NodeJS keeps running and continues to listen for new HTTP requests coming in instead of just exiting the application. Also, when we are writing or reading from a file in the background, that is also an I/O task and so it makes sense that the app doesn't exit while it's working with that file. <br /><br />

In a nutshell, the event loop is what makes asynchronous programming possible in nodeJS, making it the most important feature in node design and making nodeJS completely different from other platforms. It takes care of all incoming events and performs orchestration by offloading heavier tasks into the thread pool and doing the more simple work itself. Also remember that we need the event loop because in NodeJS everything works in a single thread so you can have thousands or millions of users accessing the same thread at the same time. This makes node lightweight and scalable but at the same time it comes at the danger of blocking our single thread which would make the entire app slow or even stop for all the users accessing the app. <br /><br />

In other languages like PHP running on an apache server, a new thread is created for each new user which is way more resource intensive but on the other hand there is no danger of blocking. It's your responsibility to not block the event loop. First off, don't use the sync versions of functions in the fs, crypto, or zlib modules in your callback functions. In my first project, I actually did use the synchronous version but it was in the top level code, so outside of any callback and since that code runs before the event loop even starts, it's no problem to use the synchronous version there. Also, don't perform very complicated calculations in the event loop. Next be careful with JSON in very large objects because at some point it may take a long time to parse or to stringify JSON. And finally, don't use all too complex regular expressions, for example with multiple nested quantifiers or back references because again they can take longer than expected. These are of course just a couple of high level guidelines but they will get you started on the right path. There are some potential solutions to these blocking problems, like manually offloading to the thread pool or using child processes.
